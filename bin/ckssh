#!/usr/bin/env bash
set -e

err() { echo 1>&2 "$@"; exit 1; }

[ -d "$XDG_RUNTIME_DIR" ] || err '$XDG_RUNTIME_DIR not set.'
ckssh_socket_dir="$XDG_RUNTIME_DIR/ckssh/socket"

meaning_of_life() { echo 42; }

strip_userat() {
    echo "$@" | sed -e 's/^[^@]*@//'
}

find_config() {
    local section=$1
    local name=$2
    local conf_file="$HOME/.ssh/ckssh_config"
    [ -r "$conf_file" ] || return 2
    sed -e '/[^ \t]*#/d' -e '/^[ \t]*$/d' "$conf_file" \
        | (while read key value; do
                case "$key" in
                    "$section")
                        if [ "$value" = "$name" ]; then
                            while read k v; do case "$k" in
                                CK_DefineCompartment|CK_Host)
                                    return 0;;
                                *)  echo "$k $v";;
                            esac; done;
                        fi;;
                    *)  : ;;
                esac
           done; return 1)
}

find_host_config()        { find_config CK_Host              "$@"; }
find_compartment_config() { find_config CK_DefineCompartment "$@"; }

# This is the pure(-ish) side of ckssh-add, designed to be
# unit-tested.  It should have as much of the logic as possible.
#
# The return value is 0 or the error code of any untested command
# within (because we set the `-e` option for this shell script).
#
# The function has the following (actually impure) results:
#
# * We may exit the process with an error; we do this here because
#   it's too hard in shell to return an error message along with
#   the error indication of the numeric return value. (These parts
#   are tested in fuctional tests.
#
# * The return value is 0 if no untested commands failed internally.
#
# * It changes the `keyfiles` global variable to be the list of files
#   from which keys should be added by the subsequent
#   `execute_ckssh_add` call.
#
ckssh_add() {
    local name="$1"
    shift || err "Usage: $(basename $0) <host or compartment name>"
    local host_compartment="$(
        find_host_config "$name" | while read key value; do
            case "$key" in
                CK_Compartment) echo "$value";;
            esac
        done
    )"
    local compartment="${host_compartment:-$name}"
    if find_compartment_config "$compartment" >/dev/null; then
        export SSH_AUTH_SOCK="$ckssh_socket_dir/$compartment"
    elif [ -n "$host_compartment" ]; then
        err "Host \"$name\" references" \
            "nonexistent compartment \"${host_compartment}\"."
    else
        err "No config for host or compartment \"$name\"."
    fi

    if [ -n "$1" ]; then
        given_keyfile_args=true
        for keyfile in "$@"; do keyfiles+=("$keyfile"); done
    else
        given_keyfile_args=false
        coproc find_compartment_config "$compartment"
        while read key value; do case "$key" in
            CK_Keyfile) keyfiles+=($(echo "$value" | sed -e "s:^~:$HOME:"));;
        esac; done <&"${COPROC[0]}"
    fi
}

# This is the impure side of ckssh-add, which should have minimal logic.
# We currently test it manually, but should build functional tests for it.
#
execute_ckssh_add() {
    mkdir -m 0700 -p $(dirname "$SSH_AUTH_SOCK")

    e=$(ssh-add -l >/dev/null 2>&1; echo $?)
    case $e in
        0) : ;;     # Running with identities
        1) : ;;     # No identities
        2) eval $(ssh-agent -a "$SSH_AUTH_SOCK" || echo false) >/dev/null;;
        *) err "Unknown error from ssh-add -l: $e";;
    esac

    if $given_keyfile_args \
       || [ $(ssh-add -l >/dev/null 2>&1; echo $?) -eq 1 ]
    then
        for keyfile in "${keyfiles[@]}"; do
            ssh-add -t 8h30m "$keyfile" || exit $?
        done
    fi
}

# Given a command name that produces help output in OpenSSH format,
# return the options that do not take a parameter.
#
get_non_param_opts() {
    local command="$1"; shift || err "INTERNAL ERROR"
    $command 2>&1 | sed -n -e 's,].*,,' -e '1s,.*\[-,,p'
}

# Find the argument indicating  the host in an ssh-style command line.
# The first argument to this function is a string of non-parameter options.
# We assume:
# 1. Any argument starting with a hyphen is an option.
# 2. Any option starting with a non-parameter option is all non-parameter
#    options. (I.e., we incorrectly assume that `-1c` has no parameter
#    though SSH would want the cipher parameter after it.)
#
get_host_arg() {
    local non_param_opts="$1"; shift || err "INTERNAL ERROR"
    local arg
    while [ -n "$1" ]; do case "$1" in
        -*) case "${1:1:1}" in                  # substring($1, 1, 1)
                [$non_param_opts])  ;;
                *)                  shift;;
            esac
            shift
            ;;
        *)  echo "$1"
            break
            ;;
    esac; done
}

# XXX This cannot properly echo an argument list starting with
# `-e` or `-n`.  # So this can break ckssh if someone does,
# e.g., 'ssh -e X ...'. (Maybe use printf instead?)
#
print0_arg() { echo -e -n "$1\0"; }

print0_ssh_args() {
    local non_param_opts="$1"; shift || err "INTERNAL ERROR"

    # Print supplied command-line args (XXX modified inline of get_host_arg).
    while [ -n "$1" ]; do case "$1" in
        -*) case "${1:1:1}" in                  # substring($1, 1, 1)
                [$non_param_opts])  print0_arg "$1";;
                *)                  print0_arg "$1"; shift; print0_arg "$1";;
            esac
            shift
            ;;
        *)  break;;
    esac; done

    # Print ssh args for "host" from ckssh config file.
    find_host_config "$(strip_userat "$1")" | while read key value; do
        case "$key" in
            CK_Compartment) : ;;
            *)              print0_arg -o; print0_arg "$key $value";;
        esac
    done

    # Find compartment. (We can't set the var above because the while is
    # in a subshell due to the pipe.)
    local compartment="$(
    find_host_config "$(strip_userat "$1")" | while read key value; do
        case "$key" in
            CK_Compartment) echo "$value"; break;;
            *)              : ;;
        esac
    done
    )"

    # Print ssh args for compartment from ckssh config file.
    find_compartment_config "$compartment" | while read key value; do
        case "$key" in
            CK_Keyfile)     : ;;
            *)              print0_arg -o; print0_arg "$key $value";;
        esac
    done

    # Print host and additional args.
    for arg in "$@"; do print0_arg "$arg"; done
}

usage() {
    echo 1>&2 "Usage: ck$1 [ssh-options] hostname [command]"
    exit 255
}


unset SSH_AUTH_SOCK
given_keyfile_args=OVERRIDE_THIS
keyfiles=()
case $(basename "$0") in
    bats-exec-test)
        : ;;                        # Unit test mode hack
    ckssh)
        [ -z "$1" ] && usage ssh
        non_param_opts="$(get_non_param_opts ssh)"
        ckssh_add "$(get_host_arg "$non_param_opts" "$@")"; execute_ckssh_add
        print0_ssh_args "$non_param_opts" "$@" | xargs -0 ssh
        ;;
    ckscp)
        [ -z "$1" ] && usage scp
        err "XXX Not implemented yet."
        ;;
    ckssh-add)
        ckssh_add "$@"; execute_ckssh_add
        echo "export SSH_AUTH_SOCK=$SSH_AUTH_SOCK"
        ;;
    *)                  err "Unknown command";;
esac
