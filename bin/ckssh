#!/usr/bin/env bash
set -e

err() { echo 1>&2 "$@"; exit 1; }
err255() { echo 1>&2 "$@"; exit 255; }

[ -d "$XDG_RUNTIME_DIR" ] || err '$XDG_RUNTIME_DIR not set.'
ckssh_runtime_dir="$XDG_RUNTIME_DIR/ckssh"
ckssh_tmp_dir="$ckssh_runtime_dir/tmp"
mkdir -m 0700 -p "$ckssh_tmp_dir"
trap "rm -f $ckssh_tmp_dir/$$.*" EXIT

ckssh_socket_dir="$ckssh_runtime_dir/socket"


# Given a top-level "match-type" directive and its value to match, print
# out all lines of our configuration that match. The rules are basically
# the same as `ssh_config`, with the caveat that there are two different
# types of matching directives, one for hosts and one for compartments.
#
# Note that, even though you pass in the top-level match-type directive
# to match, this still has to know internally all top-level match-type
# directives so it can skip the other types that can never match.
#
# Returns 1 on search item not found and 10 on config file not found
#
print_config() {
    local section=$1
    local name=$2
    local conf_file="$HOME/.ssh/ckssh_config"
    [ -r "$conf_file" ] || return 10

    sed -e '/[^ \t]*#/d' -e '/^[ \t]*$/d' "$conf_file" \
        | (retval=1
           printing=echo
           while read key value; do
                case "$key" in
                    "$section")
                        if [ "$value" = "$name" ]; then
                            retval=0
                            printing=echo
                        else
                           printing=':'
                        fi
                        ;;
                    CK_Compartment|CK_Host)
                        printing=':';;
                    *)
                        $printing "$key $value";;
                esac
           done; return $retval)
}

print_host_config()        { print_config CK_Host        "$@"; }
print_compartment_config() { print_config CK_Compartment "$@"; }

# load_*_config <config_array_name> <name>
#
# Search for the compartment or host matching <name> in the
# configuration file, returning 0 if it's found. If found, the
# configuration lines are appended to the (global) array named
# <config_array_name>.
#
# `load_compartment_config` will return 1 if the compartment is not
# defined in the configuration file. `load_host_config` will return 1
# if a pattern matching the host is not found in the configuration
# file, and will exit with an error message if the host specifies a
# compartment that does not exist.
#
# Note that, at least for the moment, `CK_Compartment` definitions
# must be an exact name, not a wildcard, as the wildcard use case not
# entirely clear.
#
# XXX `CK_Host` configurations should match host patterns, but do not
# do that yet.
#
load_compartment_config() {
    local -n config_array="$1"
    local compartment="$2"

    print_compartment_config "$compartment" >/dev/null || return $?
    while read line; do
        config_array+=("$line")
    done < <(print_compartment_config "$compartment")
}
load_host_config() {
    local -n config_array="$1"
    local host="$2"

    print_host_config "$host" >/dev/null || return $?
    while read line; do
        config_array+=("$line")
    done < <(print_host_config "$host")
}

extract_compartment_name() {
    local -n comp="$1"
    local -n host_conf="$2"
    for i in "${!host_conf[@]}"; do
        local name value
        read name value < <(echo "${host_conf[$i]}")
        case "$name" in CK_CompartmentName)
            [ -z "$comp" ] && comp="$value"
            unset host_conf[$i]
        esac
    done
}

expand_tilde() { echo "$*" | sed -e "s:^~/:$HOME/:"; }

extract_keyfiles() {
    local -n keyfiles_array="$1"
    local -n config_array="$2"

    for i in "${!config_array[@]}"; do
        local name value
        read name value < <(echo "${config_array[$i]}")
        case "$name" in CK_Keyfile)
            keyfiles_array+=("$(expand_tilde "$value")");;
        esac
    done
}

ensure_agent() {
    local compartment="$1"
    local ssh_command="$2"

    #### Setup environment
    ssh_add="${ssh_command:-ssh}-add"
    mkdir -m 0700 -p "$(dirname "$SSH_AUTH_SOCK")"
    export SSH_AUTH_SOCK="$ckssh_socket_dir/$compartment"

    #### Start agent if not already running
    e="$("$ssh_add" -l >/dev/null 2>&1; echo $?)"
    case $e in
        0) : ;;     # Running with identities
        1) : ;;     # No identities
        2) eval "$(ssh-agent -a "$SSH_AUTH_SOCK" || echo false)" >/dev/null;;
        *) err "Unknown error from $ssh_add -l: $e";;
    esac
}

load_keys() {
    local -n keys="$1"
    for keyfile in "${keys[@]}"; do
        "$ssh_add" -t 8h30m "$keyfile" || exit $?
    done
}

ckssh_add() {
    local compartment="$1"
    shift || err "Usage: $(basename $0) <compartment-name>"

    #### Read compartment config
    local -a config
    local retval=0
    load_compartment_config config "$compartment" || retval=$?
    case $retval in
         0) : ;;
         1) err "No config for compartment \"$compartment\".";;
        10) err "Config file not found";;
         *) err "INTERNAL ERROR $retval at $BASH_LINENO";;
    esac

    #### Parse CK_SSHCommand
    local ssh_command
    for i in "${!config[@]}"; do
        local name value
        read name value < <(echo "${config[$i]}")
        case "$name" in CK_SSHCommand)
            [ -z "$ssh_command" ] && ssh_command="$(expand_tilde "$value")";;
        esac
    done

    #### Parse command line args
    local keyfiles given_keyfile_args
    if [ -n "$1" ]; then
        given_keyfile_args=true
        for keyfile in "$@"; do keyfiles+=("$keyfile"); done
    else
        given_keyfile_args=false
        extract_keyfiles keyfiles config
    fi

    ensure_agent "$compartment" "$ssh_command"

    #### Add keys if none loaded or given on command line
    if $given_keyfile_args \
       || [ "$("$ssh_add" -l >/dev/null 2>&1; echo $?)" -eq 1 ]
    then
        load_keys keyfiles
    fi
}

# Given a command name that produces help output in OpenSSH format,
# return the options that do not take a parameter.
#
get_non_param_opts() {
    local command="$1"; shift || err "INTERNAL ERROR"
    $command 2>&1 | sed -n -e 's,].*,,' -e '1s,.*\[-,,p'
}

# Find the argument indicating  the host in an ssh-style command line.
# The first argument to this function is a string of non-parameter options.
# We assume:
# 1. Any argument starting with a hyphen is an option.
# 2. Any option starting with a non-parameter option is all non-parameter
#    options. (I.e., we incorrectly assume that `-1c` has no parameter
#    though SSH would want the cipher parameter after it.)
#
get_host_arg() {
    local non_param_opts="$1"; shift || err "INTERNAL ERROR"
    local arg
    while [ -n "$1" ]; do case "$1" in
        -*) case "${1:1:1}" in                  # substring($1, 1, 1)
                [$non_param_opts])  ;;
                *)                  shift;;
            esac
            shift
            ;;
        *)  echo "$1"
            break
            ;;
    esac; done
}

strip_userat() {
    echo "$@" | sed -e 's/^[^@]*@//'
}

print0_arg() { echo -e -n "$1\0"; }

# For compatibility with ssh, we must always exit with 255 on any
# error before the remote command runs, otherwise we exit with the
# remote command's status code.
#
ckssh() {
    [ $# = 0 ] \
        && err255 "usage: $(basename $0) [ssh-params ...] [user@]host [cmd...]"

    #### Read host config
    local host="$(strip_userat $(get_host_arg $(get_non_param_opts ssh) "$@"))"
    local -a config
    local retval=0
    load_host_config config "$host" || retval=$?
    case $retval in
         0) : ;;
         1) err255 "$(basename $0): No config for host '$host'";;
        10) err255 "$(basename $0): Config file not found";;
         *) err255 "$(basename $0): INTERNAL ERROR $retval at $BASH_LINENO";;
    esac

    local compartment
    extract_compartment_name compartment config
    load_compartment_config config "$compartment" || retval=$?
    case $retval in
        0) : ;;
        1) err255 "$(basename $0): No config for compartment '$compartment'";;
        *) err255 "$(basename $0): INTERNAL ERROR $retval at $BASH_LINENO";;
    esac

    #### Parse CK_SSHCommand
    local ssh_command
    for i in "${!config[@]}"; do
        local name value
        read name value < <(echo "${config[$i]}")
        case "$name" in CK_SSHCommand)
            [ -z "$ssh_command" ] && ssh_command="$(expand_tilde "$value")"
            unset config[$i]
            ;;
        esac
    done

    ##### Build command line
    local arg_file=$ckssh_tmp_dir/$$.args
    > $arg_file
    # Options given to ckssh
    while [ -n "$1" ]; do case "$1" in
        -*) case "${1:1:1}" in                  # substring($1, 1, 1)
                [$non_param_opts])  print0_arg "$1" ;;
                *)                  print0_arg "$1"; shift; print0_arg "$1";;
            esac
            shift
            ;;
        *)  break;;
    esac; done >> $arg_file
    # Options from ckssh configuration file
    for arg in "${config[@]}"; do
        print0_arg -o
        print0_arg "$arg"
    done >> $arg_file

    # Remainder of ckssh command line options
    for arg in "$@"; do print0_arg "$arg" >> $arg_file; done

    exec xargs -0 -a $arg_file $ssh_command
}

unset SSH_AUTH_SOCK
case "$(basename "$0")" in
    bats-exec-test)     : ;;                        # Unit test mode hack
    ckssh)              ckssh "$@";;
    ckssh-add)          ckssh_add "$@"
                        echo "export SSH_AUTH_SOCK=$SSH_AUTH_SOCK"
                        ;;
    *)                  err "Unknown command";;
esac
